<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Code/game.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Code/game.py" />
              <option name="originalContent" value="import pygame&#10;import sys&#10;from scoreManager import ScoreManager&#10;from player import Player&#10;import obstacle&#10;from alien import Alien, Extra&#10;from random import choice, randint, random&#10;from laser import Laser&#10;from menu import MainMenu&#10;from pathlib import Path&#10;&#10;class Game:&#10;&#10;&#10;    def __init__(self, screen, screen_width, screen_height):&#10;        self.screen = screen&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        # Directorio base del proyecto (un nivel arriba de Code)&#10;        BASE_DIR = Path(__file__).resolve().parent.parent&#10;        AUDIO_DIR = BASE_DIR / 'Audio'&#10;&#10;        # Inicializar score_manager correctamente&#10;        score_manager = ScoreManager('scores.txt')&#10;&#10;        # configuration de la nave&#10;        player_sprite = Player((screen_width / 2, screen_height), screen_width, 5)&#10;        self.player = pygame.sprite.GroupSingle(player_sprite)&#10;&#10;        # configuration del obstacle&#10;        self.shape = obstacle.shape1&#10;        self.block_size = 6&#10;        self.blocks = pygame.sprite.Group()&#10;        self.obstacle_amount = 4&#10;        &quot;&quot;&quot;&quot;&quot; Se crea un arreglo el cual posee el offset para la creación de cada obstaculo en base al número de obstáculos&#10;        de la variable obstacle_amount, así pues se multiplicará cada uno de los números en el rango de&#10;        obstacle_amount por el largo de la pantalla dividido para los obstaculos totales a generar&quot;&quot;&quot;&quot;&quot;&#10;        self.obstacle_x_position = [num * (screen_width / self.obstacle_amount) for num in range(self.obstacle_amount)]&#10;        self.create_multiple_obstacles(*self.obstacle_x_position, x_start=screen_width / 15, y_start=480)&#10;&#10;        # Alien setup&#10;        self.aliens = pygame.sprite.Group()&#10;        self.alien_setup(rows=5, cols=8)&#10;        self.alien_laser = pygame.sprite.Group()&#10;        self.alien_direction = 1&#10;        self.alien_killed = 0&#10;        self.in_main_menu = False&#10;        self.main_menu = MainMenu(screen_width,screen_height, score_manager)&#10;&#10;        # Extra setup&#10;        self.extra = pygame.sprite.GroupSingle()&#10;        self.extra_spawn_time = randint(40, 80)&#10;&#10;        # Player&#10;        self.lives = 3&#10;        self.game_over = False&#10;&#10;        # pause game&#10;        self.paused = False&#10;        self.font = pygame.font.Font(None, 36)&#10;&#10;        # Administrador de puntajes&#10;        self.score_manager = score_manager&#10;        self.score_manager.load_scores()&#10;&#10;        #Audio&#10;        music = pygame.mixer.Sound(str(AUDIO_DIR / 'music.wav'))&#10;        music.set_volume(0.1)&#10;        music.play(loops=-1)&#10;        self.explosion_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'explosion.wav'))&#10;        self.explosion_sound.set_volume(0.3)&#10;        self.game_over_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'gameOver.mp3'))&#10;        self.game_over_sound.set_volume(0.5)&#10;        self.alien_laser_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'laserAlien.wav'))&#10;        self.alien_laser_sound.set_volume(0.3)&#10;    # Lógica de obstáculos&#10;    def create_obstacle(self, x_start, y_start, offset_x):&#10;        # En base a u sistema de matrices se añadira bloques para formar un obstaculo.&#10;        for row_index, row in enumerate(self.shape):&#10;            for col_index, col in enumerate(row):&#10;                if col == 'x':&#10;                    &quot;&quot;&quot;&quot;&quot; La posición del bloque es su índice multiplicado por el tamaño del bloque (para que los bloques no se encimen)&#10;                    y a eso se le suma una distancia inicial tanto en x como y. Además en x se le&#10;                    suma un offset_x pues posteriormente se dibujará más objetos y si no colocamos&#10;                    esa variable los objetos se dibujara uno encima de otro.&quot;&quot;&quot;&quot;&quot;&#10;                    x = x_start + col_index * self.block_size + offset_x&#10;                    y = y_start + row_index * self.block_size&#10;                    block = obstacle.Block(self.block_size, (241, 79, 80), x, y)&#10;                    self.blocks.add(block)&#10;&#10;    def create_multiple_obstacles(self, *offset, x_start, y_start):&#10;        for offset_x in offset:&#10;            self.create_obstacle(x_start, y_start, offset_x)&#10;&#10;    def regenerate_obstacles(self):&#10;        self.blocks.empty()&#10;        self.create_multiple_obstacles(*self.obstacle_x_position, x_start=self.screen_width / 15, y_start=480)&#10;&#10;    # Lógica de enemigos aliens&#10;    def alien_setup(self, rows, cols, x_distance=60, y_distance=48, x_offset=70, y_offset=90):&#10;        for row_index, row in enumerate(range(rows)):&#10;            for col_index, col in enumerate(range(cols)):&#10;                x = col_index * x_distance + x_offset&#10;                y = row_index * y_distance + y_offset&#10;                if row_index == 0:&#10;                    alien_sprite = Alien('yellow', x, y)&#10;                elif 1 &lt;= row_index &lt;= 2:&#10;                    alien_sprite = Alien('green', x, y)&#10;                else:&#10;                    alien_sprite = Alien('red', x, y)&#10;                self.aliens.add(alien_sprite)&#10;&#10;    def alien_position_checker(self):&#10;        all_aliens = self.aliens.sprites()&#10;        for alien in all_aliens:&#10;            if alien.rect.right &gt;= self.screen_width:&#10;                self.alien_direction = -1 - self.alien_killed&#10;                self.alien_move_down(2)&#10;            elif alien.rect.left &lt;= 0:&#10;                self.alien_direction = 1 + self.alien_killed&#10;                self.alien_move_down(2)&#10;&#10;    def alien_move_down(self, distance):&#10;        if self.aliens:&#10;            for alien in self.aliens.sprites():&#10;                alien.rect.y += distance&#10;&#10;    def alien_shoot(self):&#10;        if self.aliens.sprites():&#10;            # Elegir aleatoriamente un enemigo con probabilidad adicional para las filas superiores&#10;            upper_row_prob = 0.8  # Probabilidad de que tome valores de arriba de la mitad de la pantalla&#10;            random_alien = None&#10;&#10;            if random() &lt; upper_row_prob:&#10;                # Elegir un enemigo de las filas superiores con más probabilidad (enemigos con posición por encima de la mitad de la pantalla)&#10;                upper_row_aliens = [alien for alien in self.aliens.sprites() if alien.rect.y &lt; self.screen_height / 2]&#10;                if upper_row_aliens:&#10;                    random_alien = choice(upper_row_aliens)&#10;&#10;            if random_alien is None:&#10;                # Si no hay enemigos en las filas superiores o no se cumple la probabilidad,&#10;                # elegir un enemigo al azar de todos los enemigos&#10;                random_alien = choice(self.aliens.sprites())&#10;&#10;            laser_sprite = Laser(random_alien.rect.center, 4, self.screen_height)&#10;            self.alien_laser.add(laser_sprite)&#10;            self.alien_laser_sound.play()&#10;&#10;    def extra_alien_timer(self):&#10;        self.extra_spawn_time -= 1&#10;        if self.extra_spawn_time &lt;= 0:&#10;            self.extra.add(Extra(choice(['right', 'left']), self.screen_width))&#10;            self.extra_spawn_time = randint(400, 800)&#10;&#10;    def create_new_wave(self):&#10;        self.aliens.empty()  # Clear the existing alien group&#10;        self.alien_setup(rows=5, cols=8)  # Create a new wave of aliens&#10;        self.alien_direction = 1  # Reset alien movement direction&#10;&#10;        self.regenerate_obstacles()&#10;&#10;    # Lógica de colisiones&#10;    def collision_checks(self):&#10;        # player lasers&#10;        if self.player.sprite.lasers:&#10;            for laser in self.player.sprite.lasers:&#10;                # obstacle collisions&#10;                if pygame.sprite.spritecollide(laser, self.blocks, True):&#10;                    laser.kill()&#10;&#10;                # alien collisions&#10;                # if pygame.sprite.spritecollide(laser, self.aliens, True):&#10;                #   laser.kill()&#10;                # puntuacion al destruir los aliens&#10;                aliens_hit = pygame.sprite.spritecollide(laser, self.aliens, True)&#10;                for alien in aliens_hit:&#10;                    laser.kill()&#10;                    self.player.sprite.score += alien.score_value&#10;                    self.alien_killed += 0.03  # tasa de incremento de velocidad cuando un alien es eliminado&#10;                    self.explosion_sound.play()&#10;                # extra collision&#10;                if pygame.sprite.spritecollide(laser, self.extra, True):&#10;                    laser.kill()&#10;&#10;        # alien lasers&#10;        if self.alien_laser:&#10;            for laser in self.alien_laser:&#10;                # obstacle collisions&#10;                if pygame.sprite.spritecollide(laser, self.blocks, True):&#10;                    laser.kill()&#10;&#10;                if pygame.sprite.spritecollide(laser, self.player, False):&#10;                    laser.kill()&#10;                    # vidas del jugador&#10;                    self.lives -= 1&#10;                    if self.lives &lt;= 0:&#10;                        print('EL JUGADOR A MUERTO')&#10;                        self.game_over_sound.play()&#10;                        self.lives = 0&#10;                        self.game_over = True&#10;&#10;        # aliens&#10;        if self.aliens:&#10;            for alien in self.aliens:&#10;                pygame.sprite.spritecollide(alien, self.blocks, True)&#10;&#10;                if pygame.sprite.spritecollide(alien, self.player, False):&#10;                    #pygame.quit()&#10;&#10;                    self.game_over = True  #Game over&#10;&#10;                    #sys.exit()&#10;&#10;    def return_to_main_menu(self):&#10;        # Solo dibujar el menú; el bucle principal debe encargarse de manejar eventos&#10;        self.main_menu.draw(self.screen)&#10;&#10;    def clear_screen(self):&#10;        self.screen.fill((0, 0, 0))  # Llena la pantalla con color negro&#10;        self.blocks.empty()  # Limpia los obstáculos&#10;        self.aliens.empty()  # Limpia los aliens&#10;        self.player.sprite.lasers.empty()  # Limpia los láseres del jugador&#10;        self.alien_laser.empty()  # Limpia los láseres de los aliens&#10;        self.extra.empty()  # Limpia los elementos extras&#10;&#10;    #restart&#10;    def restart_level(self):&#10;        # Reiniciar el estado del nivel para comenzar de nuevo&#10;        self.clear_screen()&#10;        self.alien_killed = 0&#10;        # Resetear puntuación del jugador&#10;        if self.player and self.player.sprite:&#10;            self.player.sprite.score = 0&#10;            # Reposicionar la nave al centro inferior (usar ints)&#10;            self.player.sprite.rect.midbottom = (int(self.screen_width / 2), int(self.screen_height))&#10;        self.lives = 3  # Vidas iniciales&#10;        self.game_over = False&#10;        self.paused = False&#10;        # Resetear movimiento y láseres de los aliens/extras&#10;        self.alien_direction = 1&#10;        if hasattr(self, 'alien_laser'):&#10;            self.alien_laser.empty()&#10;        if hasattr(self, 'extra'):&#10;            self.extra.empty()&#10;            # resetear timer para spawn de extra&#10;            self.extra_spawn_time = randint(40, 80)&#10;        # Reiniciar oleada y obstáculos&#10;        self.create_new_wave()&#10;        self.regenerate_obstacles()&#10;&#10;    def run(self):&#10;        self.player.update()&#10;        self.aliens.update(self.alien_direction)&#10;        self.alien_position_checker()&#10;        self.alien_laser.update()&#10;        self.extra_alien_timer()&#10;        self.extra.update()&#10;        self.collision_checks()&#10;&#10;        self.player.sprite.lasers.draw(self.screen)&#10;        self.player.draw(self.screen)&#10;&#10;        self.blocks.draw(self.screen)&#10;        self.aliens.draw(self.screen)&#10;        self.alien_laser.draw(self.screen)&#10;        self.extra.draw(self.screen)&#10;        # update all sprite groups&#10;        # draw all sprite&#10;&#10;        if self.in_main_menu:&#10;            self.return_to_main_menu()&#10;            return&#10;&#10;        # Revisar si todos los enemigos han sido eliminados&#10;        if len(self.aliens) == 0:&#10;            self.create_new_wave()&#10;            # aumentar una vida (no sobrepasar 6)&#10;            if (self.lives) &lt;= 6:&#10;                self.lives += 1&#10;&#10;        # vidas&#10;        font = pygame.font.Font(None, 30)&#10;        lives_text = font.render(f'Lives: {self.lives}', True, (255, 255, 255))&#10;        self.screen.blit(lives_text, (10, 20))  # Ajusta la posición según la preferencia&#10;&#10;        # puntuacion&#10;        font = pygame.font.Font(None, 30)  # Se puede borrar esta línea&#10;        score_text = font.render(f'Score: {self.player.sprite.score}', True, (255, 255, 255))&#10;        self.screen.blit(score_text, (110, 20))  # Ajusta la posición según la preferencia&#10;&#10;        # Nota: El manejo de eventos (teclas) debe hacerse en el loop principal (main.py)&#10;        # para evitar consumir eventos varias veces. Aquí solo se dibuja/actualiza el estado.&#10;&#10;        # Game over&#10;        if self.game_over:&#10;            font = pygame.font.Font(None, 80)&#10;            game_over_text = font.render(&quot;Game Over&quot;, True, (255, 0, 0))&#10;            self.screen.blit(game_over_text, (self.screen_width // 2 - 120, self.screen_height // 2))&#10;            pygame.display.flip()&#10;&#10;            # Guardar el puntaje actual&#10;            self.score_manager.add_score(self.player.sprite.score)&#10;            self.score_manager.save_scores()&#10;            return  # Detener la actualización si el juego ha terminado&#10;&#10;        # clock.tick(60)&#10;" />
              <option name="updatedContent" value="import pygame&#10;import sys&#10;from scoreManager import ScoreManager&#10;from player import Player&#10;import obstacle&#10;from alien import Alien, Extra&#10;from random import choice, randint, random&#10;from laser import Laser&#10;from menu import MainMenu&#10;from pathlib import Path&#10;&#10;class Game:&#10;&#10;&#10;    def __init__(self, screen, screen_width, screen_height):&#10;        self.screen = screen&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        # Directorio base del proyecto (un nivel arriba de Code)&#10;        BASE_DIR = Path(__file__).resolve().parent.parent&#10;        AUDIO_DIR = BASE_DIR / 'Audio'&#10;&#10;        # Inicializar score_manager correctamente&#10;        score_manager = ScoreManager('scores.txt')&#10;&#10;        # configuration de la nave&#10;        player_sprite = Player((screen_width / 2, screen_height), screen_width, 5)&#10;        self.player = pygame.sprite.GroupSingle(player_sprite)&#10;&#10;        # configuration del obstacle&#10;        self.shape = obstacle.shape1&#10;        self.block_size = 6&#10;        self.blocks = pygame.sprite.Group()&#10;        self.obstacle_amount = 4&#10;        &quot;&quot;&quot;&quot;&quot; Se crea un arreglo el cual posee el offset para la creación de cada obstaculo en base al número de obstáculos&#10;        de la variable obstacle_amount, así pues se multiplicará cada uno de los números en el rango de&#10;        obstacle_amount por el largo de la pantalla dividido para los obstaculos totales a generar&quot;&quot;&quot;&quot;&quot;&#10;        self.obstacle_x_position = [num * (screen_width / self.obstacle_amount) for num in range(self.obstacle_amount)]&#10;        self.create_multiple_obstacles(*self.obstacle_x_position, x_start=screen_width / 15, y_start=480)&#10;&#10;        # Alien setup&#10;        self.aliens = pygame.sprite.Group()&#10;        self.alien_setup(rows=5, cols=8)&#10;        self.alien_laser = pygame.sprite.Group()&#10;        self.alien_direction = 1&#10;        self.alien_killed = 0&#10;        self.in_main_menu = False&#10;        self.main_menu = MainMenu(screen_width,screen_height, score_manager)&#10;&#10;        # Extra setup&#10;        self.extra = pygame.sprite.GroupSingle()&#10;        self.extra_spawn_time = randint(40, 80)&#10;&#10;        # Player&#10;        self.lives = 3&#10;        self.game_over = False&#10;&#10;        # pause game&#10;        self.paused = False&#10;        self.font = pygame.font.Font(None, 36)&#10;&#10;        # Administrador de puntajes&#10;        self.score_manager = score_manager&#10;        self.score_manager.load_scores()&#10;&#10;        #Audio&#10;        music = pygame.mixer.Sound(str(AUDIO_DIR / 'music.wav'))&#10;        music.set_volume(0.1)&#10;        music.play(loops=-1)&#10;        self.explosion_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'explosion.wav'))&#10;        self.explosion_sound.set_volume(0.3)&#10;        self.game_over_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'gameOver.mp3'))&#10;        self.game_over_sound.set_volume(0.5)&#10;        self.alien_laser_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'laserAlien.wav'))&#10;        self.alien_laser_sound.set_volume(0.3)&#10;    # Lógica de obstáculos&#10;    def create_obstacle(self, x_start, y_start, offset_x):&#10;        # En base a u sistema de matrices se añadira bloques para formar un obstaculo.&#10;        for row_index, row in enumerate(self.shape):&#10;            for col_index, col in enumerate(row):&#10;                if col == 'x':&#10;                    &quot;&quot;&quot;&quot;&quot; La posición del bloque es su índice multiplicado por el tamaño del bloque (para que los bloques no se encimen)&#10;                    y a eso se le suma una distancia inicial tanto en x como y. Además en x se le&#10;                    suma un offset_x pues posteriormente se dibujará más objetos y si no colocamos&#10;                    esa variable los objetos se dibujara uno encima de otro.&quot;&quot;&quot;&quot;&quot;&#10;                    x = x_start + col_index * self.block_size + offset_x&#10;                    y = y_start + row_index * self.block_size&#10;                    block = obstacle.Block(self.block_size, (241, 79, 80), x, y)&#10;                    self.blocks.add(block)&#10;&#10;    def create_multiple_obstacles(self, *offset, x_start, y_start):&#10;        for offset_x in offset:&#10;            self.create_obstacle(x_start, y_start, offset_x)&#10;&#10;    def regenerate_obstacles(self):&#10;        self.blocks.empty()&#10;        self.create_multiple_obstacles(*self.obstacle_x_position, x_start=self.screen_width / 15, y_start=480)&#10;&#10;    # Lógica de enemigos aliens&#10;    def alien_setup(self, rows, cols, x_distance=60, y_distance=48, x_offset=70, y_offset=90):&#10;        for row_index, row in enumerate(range(rows)):&#10;            for col_index, col in enumerate(range(cols)):&#10;                x = col_index * x_distance + x_offset&#10;                y = row_index * y_distance + y_offset&#10;                if row_index == 0:&#10;                    alien_sprite = Alien('yellow', x, y)&#10;                elif 1 &lt;= row_index &lt;= 2:&#10;                    alien_sprite = Alien('green', x, y)&#10;                else:&#10;                    alien_sprite = Alien('red', x, y)&#10;                self.aliens.add(alien_sprite)&#10;&#10;    def alien_position_checker(self):&#10;        all_aliens = self.aliens.sprites()&#10;        for alien in all_aliens:&#10;            if alien.rect.right &gt;= self.screen_width:&#10;                self.alien_direction = -1 - self.alien_killed&#10;                self.alien_move_down(2)&#10;            elif alien.rect.left &lt;= 0:&#10;                self.alien_direction = 1 + self.alien_killed&#10;                self.alien_move_down(2)&#10;&#10;    def alien_move_down(self, distance):&#10;        if self.aliens:&#10;            for alien in self.aliens.sprites():&#10;                alien.rect.y += distance&#10;&#10;    def alien_shoot(self):&#10;        if self.aliens.sprites():&#10;            # Elegir aleatoriamente un enemigo con probabilidad adicional para las filas superiores&#10;            upper_row_prob = 0.8  # Probabilidad de que tome valores de arriba de la mitad de la pantalla&#10;            random_alien = None&#10;&#10;            if random() &lt; upper_row_prob:&#10;                # Elegir un enemigo de las filas superiores con más probabilidad (enemigos con posición por encima de la mitad de la pantalla)&#10;                upper_row_aliens = [alien for alien in self.aliens.sprites() if alien.rect.y &lt; self.screen_height / 2]&#10;                if upper_row_aliens:&#10;                    random_alien = choice(upper_row_aliens)&#10;&#10;            if random_alien is None:&#10;                # Si no hay enemigos en las filas superiores o no se cumple la probabilidad,&#10;                # elegir un enemigo al azar de todos los enemigos&#10;                random_alien = choice(self.aliens.sprites())&#10;&#10;            laser_sprite = Laser(random_alien.rect.center, 4, self.screen_height)&#10;            self.alien_laser.add(laser_sprite)&#10;            self.alien_laser_sound.play()&#10;&#10;    def extra_alien_timer(self):&#10;        self.extra_spawn_time -= 1&#10;        if self.extra_spawn_time &lt;= 0:&#10;            self.extra.add(Extra(choice(['right', 'left']), self.screen_width))&#10;            self.extra_spawn_time = randint(400, 800)&#10;&#10;    def create_new_wave(self):&#10;        self.aliens.empty()  # Clear the existing alien group&#10;        self.alien_setup(rows=5, cols=8)  # Create a new wave of aliens&#10;        self.alien_direction = 1  # Reset alien movement direction&#10;&#10;        self.regenerate_obstacles()&#10;&#10;    # Lógica de colisiones&#10;    def collision_checks(self):&#10;        # player lasers&#10;        if self.player.sprite.lasers:&#10;            for laser in self.player.sprite.lasers:&#10;                # obstacle collisions&#10;                if pygame.sprite.spritecollide(laser, self.blocks, True):&#10;                    laser.kill()&#10;&#10;                # alien collisions&#10;                # if pygame.sprite.spritecollide(laser, self.aliens, True):&#10;                #   laser.kill()&#10;                # puntuacion al destruir los aliens&#10;                aliens_hit = pygame.sprite.spritecollide(laser, self.aliens, True)&#10;                for alien in aliens_hit:&#10;                    laser.kill()&#10;                    self.player.sprite.score += alien.score_value&#10;                    self.alien_killed += 0.03  # tasa de incremento de velocidad cuando un alien es eliminado&#10;                    self.explosion_sound.play()&#10;                # extra collision&#10;                if pygame.sprite.spritecollide(laser, self.extra, True):&#10;                    laser.kill()&#10;&#10;        # alien lasers&#10;        if self.alien_laser:&#10;            for laser in self.alien_laser:&#10;                # obstacle collisions&#10;                if pygame.sprite.spritecollide(laser, self.blocks, True):&#10;                    laser.kill()&#10;&#10;                if pygame.sprite.spritecollide(laser, self.player, False):&#10;                    laser.kill()&#10;                    # vidas del jugador&#10;                    self.lives -= 1&#10;                    # Reproducir sonido de explosión y activar parpadeo&#10;                    self.explosion_sound.play()&#10;                    self.player.sprite.take_damage()&#10;                    if self.lives &lt;= 0:&#10;                        print('EL JUGADOR A MUERTO')&#10;                        self.game_over_sound.play()&#10;                        self.lives = 0&#10;                        self.game_over = True&#10;&#10;        # aliens&#10;        if self.aliens:&#10;            for alien in self.aliens:&#10;                pygame.sprite.spritecollide(alien, self.blocks, True)&#10;&#10;                if pygame.sprite.spritecollide(alien, self.player, False):&#10;                    #pygame.quit()&#10;&#10;                    self.game_over = True  #Game over&#10;&#10;                    #sys.exit()&#10;&#10;    def return_to_main_menu(self):&#10;        # Solo dibujar el menú; el bucle principal debe encargarse de manejar eventos&#10;        self.main_menu.draw(self.screen)&#10;&#10;    def clear_screen(self):&#10;        self.screen.fill((0, 0, 0))  # Llena la pantalla con color negro&#10;        self.blocks.empty()  # Limpia los obstáculos&#10;        self.aliens.empty()  # Limpia los aliens&#10;        self.player.sprite.lasers.empty()  # Limpia los láseres del jugador&#10;        self.alien_laser.empty()  # Limpia los láseres de los aliens&#10;        self.extra.empty()  # Limpia los elementos extras&#10;&#10;    #restart&#10;    def restart_level(self):&#10;        # Reiniciar el estado del nivel para comenzar de nuevo&#10;        self.clear_screen()&#10;        self.alien_killed = 0&#10;        # Resetear puntuación del jugador&#10;        if self.player and self.player.sprite:&#10;            self.player.sprite.score = 0&#10;            # Reposicionar la nave al centro inferior (usar ints)&#10;            self.player.sprite.rect.midbottom = (int(self.screen_width / 2), int(self.screen_height))&#10;            # Resetear estado de parpadeo&#10;            self.player.sprite.is_hit = False&#10;            self.player.sprite.visible = True&#10;        self.lives = 3  # Vidas iniciales&#10;        self.game_over = False&#10;        self.paused = False&#10;        # Resetear movimiento y láseres de los aliens/extras&#10;        self.alien_direction = 1&#10;        if hasattr(self, 'alien_laser'):&#10;            self.alien_laser.empty()&#10;        if hasattr(self, 'extra'):&#10;            self.extra.empty()&#10;            # resetear timer para spawn de extra&#10;            self.extra_spawn_time = randint(40, 80)&#10;        # Reiniciar oleada y obstáculos&#10;        self.create_new_wave()&#10;        self.regenerate_obstacles()&#10;&#10;    def run(self):&#10;        self.player.update()&#10;        self.aliens.update(self.alien_direction)&#10;        self.alien_position_checker()&#10;        self.alien_laser.update()&#10;        self.extra_alien_timer()&#10;        self.extra.update()&#10;        self.collision_checks()&#10;&#10;        self.player.sprite.lasers.draw(self.screen)&#10;        # Dibujar la nave solo si es visible (para el efecto de parpadeo)&#10;        if self.player.sprite.visible:&#10;            self.player.draw(self.screen)&#10;&#10;        self.blocks.draw(self.screen)&#10;        self.aliens.draw(self.screen)&#10;        self.alien_laser.draw(self.screen)&#10;        self.extra.draw(self.screen)&#10;        # update all sprite groups&#10;        # draw all sprite&#10;&#10;        if self.in_main_menu:&#10;            self.return_to_main_menu()&#10;            return&#10;&#10;        # Revisar si todos los enemigos han sido eliminados&#10;        if len(self.aliens) == 0:&#10;            self.create_new_wave()&#10;            # aumentar una vida (no sobrepasar 6)&#10;            if (self.lives) &lt;= 6:&#10;                self.lives += 1&#10;&#10;        # vidas&#10;        font = pygame.font.Font(None, 30)&#10;        lives_text = font.render(f'Lives: {self.lives}', True, (255, 255, 255))&#10;        self.screen.blit(lives_text, (10, 20))  # Ajusta la posición según la preferencia&#10;&#10;        # puntuacion&#10;        font = pygame.font.Font(None, 30)  # Se puede borrar esta línea&#10;        score_text = font.render(f'Score: {self.player.sprite.score}', True, (255, 255, 255))&#10;        self.screen.blit(score_text, (110, 20))  # Ajusta la posición según la preferencia&#10;&#10;        # Nota: El manejo de eventos (teclas) debe hacerse en el loop principal (main.py)&#10;        # para evitar consumir eventos varias veces. Aquí solo se dibuja/actualiza el estado.&#10;&#10;        # Game over&#10;        if self.game_over:&#10;            font = pygame.font.Font(None, 80)&#10;            game_over_text = font.render(&quot;Game Over&quot;, True, (255, 0, 0))&#10;            self.screen.blit(game_over_text, (self.screen_width // 2 - 120, self.screen_height // 2))&#10;            pygame.display.flip()&#10;&#10;            # Guardar el puntaje actual&#10;            self.score_manager.add_score(self.player.sprite.score)&#10;            self.score_manager.save_scores()&#10;            return  # Detener la actualización si el juego ha terminado&#10;&#10;        # clock.tick(60)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Code/player.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Code/player.py" />
              <option name="originalContent" value="import pygame&#10;from laser import Laser&#10;from pathlib import Path&#10;&#10;&#10;class Player(pygame.sprite.Sprite):&#10;    def __init__(self, pos, constraint, speed):&#10;        super().__init__()&#10;        # Cargar recursos usando rutas relativas al repositorio&#10;        BASE_DIR = Path(__file__).resolve().parent.parent&#10;        GRAPHICS_DIR = BASE_DIR / 'Graphics'&#10;        AUDIO_DIR = BASE_DIR / 'Audio'&#10;&#10;        self.image = pygame.image.load(str(GRAPHICS_DIR / 'player.png')).convert_alpha()&#10;        self.rect = self.image.get_rect(midbottom=pos)&#10;        self.speed = speed&#10;        self.max_x_constraint = constraint&#10;        #Variables para el disparo&#10;        self.ready = True&#10;        self.laser_time = 0&#10;        self.laser_cooldown = 1000&#10;        self.lasers = pygame.sprite.Group()&#10;        # Usar ruta relativa para el sonido&#10;        self.laser_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'laser.wav'))&#10;        self.laser_sound.set_volume(0.05)&#10;&#10;        #puntuacion&#10;        self.score = 0&#10;&#10;    def get_input(self):&#10;        keys = pygame.key.get_pressed()&#10;&#10;        if keys[pygame.K_RIGHT]:&#10;            self.rect.x += self.speed&#10;        elif keys[pygame.K_LEFT]:&#10;            self.rect.x -= self.speed&#10;&#10;        #Implementar mecánica de disparo&#10;        if keys[pygame.K_SPACE] and self.ready:&#10;            self.shoot_laser()&#10;            self.ready = False&#10;            self.laser_time = pygame.time.get_ticks()&#10;&#10;    def recharge(self):&#10;        &quot;&quot;&quot;Función de recarga, se vizualiza la resta entre el tiempo actual y el tiempo desde que se&#10;        disparó el ultimo proyectil, si ese tiempo es mayor al cooldawn entonces el boleano se cambia&#10;        a verdadero para volver a tener la posibilidad de dispara.&quot;&quot;&quot;&#10;        if not self.ready:&#10;            current_time = pygame.time.get_ticks()&#10;            if current_time - self.laser_time &gt; self.laser_cooldown:&#10;                self.ready = True&#10;&#10;    def constraint(self):&#10;        if self.rect.left &lt;= 0:&#10;            self.rect.left = 0&#10;        if self.rect.right &gt;= self.max_x_constraint:&#10;            self.rect.right = self.max_x_constraint&#10;&#10;    # Añadir mecánica de disparo&#10;    def shoot_laser(self):&#10;        self.lasers.add(Laser(self.rect.center,-6,self.rect.bottom))&#10;        self.laser_sound.play()&#10;    def update(self):&#10;&#10;        self.get_input()&#10;        self.constraint()&#10;        self.recharge()&#10;        self.lasers.update()" />
              <option name="updatedContent" value="import pygame&#10;from laser import Laser&#10;from pathlib import Path&#10;&#10;&#10;class Player(pygame.sprite.Sprite):&#10;    def __init__(self, pos, constraint, speed):&#10;        super().__init__()&#10;        # Cargar recursos usando rutas relativas al repositorio&#10;        BASE_DIR = Path(__file__).resolve().parent.parent&#10;        GRAPHICS_DIR = BASE_DIR / 'Graphics'&#10;        AUDIO_DIR = BASE_DIR / 'Audio'&#10;&#10;        self.image = pygame.image.load(str(GRAPHICS_DIR / 'player.png')).convert_alpha()&#10;        self.rect = self.image.get_rect(midbottom=pos)&#10;        self.speed = speed&#10;        self.max_x_constraint = constraint&#10;        #Variables para el disparo&#10;        self.ready = True&#10;        self.laser_time = 0&#10;        self.laser_cooldown = 1000&#10;        self.lasers = pygame.sprite.Group()&#10;        # Usar ruta relativa para el sonido&#10;        self.laser_sound = pygame.mixer.Sound(str(AUDIO_DIR / 'laser.wav'))&#10;        self.laser_sound.set_volume(0.05)&#10;&#10;        #puntuacion&#10;        self.score = 0&#10;&#10;        # Variables para el parpadeo cuando recibe daño&#10;        self.is_hit = False&#10;        self.hit_time = 0&#10;        self.blink_duration = 2000  # Duración del parpadeo en milisegundos (2 segundos)&#10;        self.blink_interval = 100  # Intervalo de parpadeo en milisegundos&#10;        self.visible = True&#10;&#10;    def take_damage(self):&#10;        &quot;&quot;&quot;Marca al jugador como golpeado y comienza el parpadeo&quot;&quot;&quot;&#10;        self.is_hit = True&#10;        self.hit_time = pygame.time.get_ticks()&#10;        self.visible = True&#10;&#10;    def update_blink(self):&#10;        &quot;&quot;&quot;Actualiza el estado de parpadeo del jugador&quot;&quot;&quot;&#10;        if self.is_hit:&#10;            current_time = pygame.time.get_ticks()&#10;            elapsed_time = current_time - self.hit_time&#10;            &#10;            if elapsed_time &lt; self.blink_duration:&#10;                # Alternar visibilidad basado en el intervalo de parpadeo&#10;                self.visible = (elapsed_time // self.blink_interval) % 2 == 0&#10;            else:&#10;                # Terminar el parpadeo&#10;                self.is_hit = False&#10;                self.visible = True&#10;&#10;    def get_input(self):&#10;        keys = pygame.key.get_pressed()&#10;&#10;        if keys[pygame.K_RIGHT]:&#10;            self.rect.x += self.speed&#10;        elif keys[pygame.K_LEFT]:&#10;            self.rect.x -= self.speed&#10;&#10;        #Implementar mecánica de disparo&#10;        if keys[pygame.K_SPACE] and self.ready:&#10;            self.shoot_laser()&#10;            self.ready = False&#10;            self.laser_time = pygame.time.get_ticks()&#10;&#10;    def recharge(self):&#10;        &quot;&quot;&quot;Función de recarga, se vizualiza la resta entre el tiempo actual y el tiempo desde que se&#10;        disparó el ultimo proyectil, si ese tiempo es mayor al cooldawn entonces el boleano se cambia&#10;        a verdadero para volver a tener la posibilidad de dispara.&quot;&quot;&quot;&#10;        if not self.ready:&#10;            current_time = pygame.time.get_ticks()&#10;            if current_time - self.laser_time &gt; self.laser_cooldown:&#10;                self.ready = True&#10;&#10;    def constraint(self):&#10;        if self.rect.left &lt;= 0:&#10;            self.rect.left = 0&#10;        if self.rect.right &gt;= self.max_x_constraint:&#10;            self.rect.right = self.max_x_constraint&#10;&#10;    # Añadir mecánica de disparo&#10;    def shoot_laser(self):&#10;        self.lasers.add(Laser(self.rect.center,-6,self.rect.bottom))&#10;        self.laser_sound.play()&#10;    def update(self):&#10;&#10;        self.get_input()&#10;        self.constraint()&#10;        self.recharge()&#10;        self.update_blink()  # Actualizar el estado de parpadeo&#10;        self.lasers.update()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>